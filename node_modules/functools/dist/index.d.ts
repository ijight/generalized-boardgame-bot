export declare const add: (a: number, b: number) => number;
export declare const subtract: (a: number, b: number) => number;
export declare const multiply: (a: number, b: number) => number;
export declare const divide: (a: number, b: number) => number;
/**
 * Always returns the same value supplied to it.
 */
export declare const identity: <T>(value: T) => T;
/**
 * Returns a function that always returns the same value supplied to it.
 */
export declare const always: <T>(value: T) => () => T;
/**
 * Minimum required cache interface.
 */
export interface Cache<T, U> {
    get(key: T): U | undefined;
    set(key: T, value: U): void;
    has(key: T): boolean;
}
/**
 * Optimize a function to speed up consecutive calls by caching the result of
 * calls with identical input arguments. The cache can be overridden to
 * implement features such as LRU eviction.
 */
export declare function memoize<T, U>(fn: (arg: T) => U, cache?: Cache<T, U>): (arg: T) => U;
/**
 * Memoize the result of `fn` after the first invocation.
 */
export declare function memoize0<T>(fn: () => T): () => T;
/**
 * Compare two arrays for equality.
 */
export declare function arrayEqual<T extends any[]>(prev: T, next: T): boolean;
/**
 * Memoize the result of a function based on the most recent arguments.
 */
export declare function memoizeOne<T extends any[], R>(fn: (...args: T) => R): (...args: T) => R;
/**
 * Return a function that fetches `key` from its operand.
 */
export declare function prop<K extends string | number | symbol>(key: K): <T_1 extends { [T in K]?: any; }>(obj: T_1) => T_1[K];
export declare type InvokeResult<T extends (...args: A) => any, A extends any[]> = T extends (...args: A) => infer R ? R : never;
/**
 * Return a function that calls the method name on its operand. If additional
 * arguments are given, they will be given to the method as well.
 */
export declare function invoke<K extends string | number | symbol, A extends any[]>(key: K, ...args: A): <T extends Record<K, (...args: A) => any>>(obj: T) => InvokeResult<T[K], A>;
/**
 * Throttle configuration.
 */
export interface ThrottleOptions {
    leading?: boolean;
    trailing?: boolean;
    debounce?: boolean;
}
/**
 * Wrap a function to rate-limit the function executions to once every `ms` milliseconds.
 */
export declare function throttle<T extends any[]>(fn: (...args: T) => void, ms: number, { leading, trailing, debounce }?: ThrottleOptions): ((...args: T) => void) & {
    flush: () => void;
    clear: () => void;
};
/**
 * Given a `fn`, return a wrapper that accepts an array of `fn` arguments.
 */
export declare function spread<T extends any[], R>(fn: (...args: T) => R): (args: T) => R;
/**
 * Flip a binary `fn` argument order.
 */
export declare function flip<T1, T2, R>(fn: (arg1: T1, arg2: T2) => R): (arg2: T2, arg1: T1) => R;
/**
 * Returns a partially applied `fn` with the supplied arguments.
 */
export declare function partial<U extends any[], R>(fn: (...args: U) => R): (...args: U) => R;
export declare function partial<T1, U extends any[], R>(fn: (arg1: T1, ...args: U) => R, arg1: T1): (...args: U) => R;
export declare function partial<T1, T2, U extends any[], R>(fn: (arg1: T1, arg2: T2, ...args: U) => R, arg1: T1, arg2: T2): (...args: U) => R;
export declare function partial<T1, T2, T3, U extends any[], R>(fn: (arg1: T1, arg2: T2, arg3: T3, ...args: U) => R, arg1: T1, arg2: T2, arg3: T3): (...args: U) => R;
export declare function partial<T1, T2, T3, T4, U extends any[], R>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, ...args: U) => R, arg1: T1, arg2: T2, arg3: T3, arg4: T4): (...args: U) => R;
export declare function partial<T1, T2, T3, T4, T5, U extends any[], R>(fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, ...args: U) => R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): (...args: U) => R;
/**
 * Left-to-right function composition.
 */
export declare function sequence<T1, T2>(fn1: (arg: T1) => T2): (arg: T1) => T2;
export declare function sequence<T1, T2, T3>(fn1: (arg: T1) => T2, fn2: (arg: T2) => T3): (arg: T1) => T3;
export declare function sequence<T1, T2, T3, T4>(fn1: (arg: T1) => T2, fn2: (arg: T2) => T3, fn3: (arg: T3) => T4): (arg: T1) => T4;
export declare function sequence<T1, T2, T3, T4, T5>(fn1: (arg: T1) => T2, fn2: (arg: T2) => T3, fn3: (arg: T3) => T4, fn4: (arg: T4) => T5): (arg: T1) => T5;
export declare function sequence<T1, T2, T3, T4, T5, T6>(fn1: (arg: T1) => T2, fn2: (arg: T2) => T3, fn3: (arg: T3) => T4, fn4: (arg: T4) => T5, fn5: (arg: T5) => T6): (arg: T1) => T6;
/**
 * Right-to-left function composition.
 */
export declare function compose<T1, T2>(fn1: (arg: T1) => T2): (arg: T1) => T2;
export declare function compose<T1, T2, T3>(fn2: (arg: T2) => T3, fn1: (arg: T1) => T2): (arg: T1) => T3;
export declare function compose<T1, T2, T3, T4>(fn3: (arg: T3) => T4, fn2: (arg: T2) => T3, fn1: (arg: T1) => T2): (arg: T1) => T4;
export declare function compose<T1, T2, T3, T4, T5>(fn4: (arg: T4) => T5, fn3: (arg: T3) => T4, fn2: (arg: T2) => T3, fn1: (arg: T1) => T2): (arg: T1) => T5;
export declare function compose<T1, T2, T3, T4, T5, T6>(fn5: (arg: T5) => T6, fn4: (arg: T4) => T5, fn3: (arg: T3) => T4, fn2: (arg: T2) => T3, fn1: (arg: T1) => T2): (arg: T1) => T6;
/**
 * Fix the number of receivable arguments in `origFn` to `n`.
 */
export declare function nary<U extends any[], R>(n: 0, origFn: () => R): () => R;
export declare function nary<T1, U extends any[], R>(n: 1, origFn: (arg1: T1) => R): (arg1: T1) => R;
export declare function nary<T1, T2, U extends any[], R>(n: 2, origFn: (arg1: T1, arg2: T2) => R): (arg1: T1, arg2: T2) => R;
export declare function nary<T1, T2, T3, U extends any[], R>(n: 3, origFn: (arg1: T1, arg2: T2, arg3: T3) => R): (arg1: T1, arg2: T2, arg3: T3) => R;
export declare function nary<T1, T2, T3, T4, U extends any[], R>(n: 4, origFn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R;
export declare function nary<T1, T2, T3, T4, T5, U extends any[], R>(n: 5, origFn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => R): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => R;
export declare function nary<T1, T2, T3, T4, T5, T6, U extends any[], R>(n: 6, origFn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => R): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => R;
