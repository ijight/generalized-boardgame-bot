"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = (a, b) => a + b;
exports.subtract = (a, b) => a - b;
exports.multiply = (a, b) => a * b;
exports.divide = (a, b) => a / b;
/**
 * Always returns the same value supplied to it.
 */
exports.identity = (value) => value;
/**
 * Returns a function that always returns the same value supplied to it.
 */
exports.always = (value) => () => value;
/**
 * Optimize a function to speed up consecutive calls by caching the result of
 * calls with identical input arguments. The cache can be overridden to
 * implement features such as LRU eviction.
 */
function memoize(fn, cache = new Map()) {
    return function (arg) {
        if (cache.has(arg))
            return cache.get(arg);
        const result = fn(arg);
        cache.set(arg, result);
        return result;
    };
}
exports.memoize = memoize;
/**
 * Memoize the result of `fn` after the first invocation.
 */
function memoize0(fn) {
    let cached = false;
    let result = undefined;
    return () => {
        if (!cached) {
            result = fn();
            cached = true;
        }
        return result;
    };
}
exports.memoize0 = memoize0;
/**
 * Compare two arrays for equality.
 */
function arrayEqual(prev, next) {
    const len = next.length;
    if (prev.length !== len)
        return false;
    for (let i = 0; i < len; i++) {
        if (!Object.is(prev[i], next[i]))
            return false;
    }
    return true;
}
exports.arrayEqual = arrayEqual;
/**
 * Memoize the result of a function based on the most recent arguments.
 */
function memoizeOne(fn) {
    let prevArgs;
    let result;
    return (...args) => {
        if (prevArgs === undefined || !arrayEqual(args, prevArgs)) {
            prevArgs = args;
            result = fn(...args);
        }
        return result;
    };
}
exports.memoizeOne = memoizeOne;
/**
 * Return a function that fetches `key` from its operand.
 */
function prop(key) {
    return (obj) => obj[key];
}
exports.prop = prop;
/**
 * Return a function that calls the method name on its operand. If additional
 * arguments are given, they will be given to the method as well.
 */
function invoke(key, ...args) {
    return (obj) => obj[key](...args);
}
exports.invoke = invoke;
/**
 * Wrap a function to rate-limit the function executions to once every `ms` milliseconds.
 */
function throttle(fn, ms, { leading = true, trailing = true, debounce = false } = {}) {
    let pending;
    let timeout = undefined;
    // Clear timeout.
    function clear() {
        clearTimeout(timeout);
        timeout = undefined;
        pending = undefined;
    }
    // Invoke the function in "pending" state.
    function flush() {
        clearTimeout(timeout);
        return next();
    }
    // Execute `fn` and increment timeout every loop.
    function next() {
        timeout = undefined;
        if (!pending)
            return;
        const args = pending;
        pending = undefined;
        if (trailing)
            fn(...args);
        timeout = setTimeout(next, ms);
    }
    // Throttled `fn` wrapper.
    function throttled(...args) {
        pending = args;
        if (timeout === undefined) {
            if (leading) {
                pending = undefined;
                fn(...args);
            }
            timeout = setTimeout(next, ms);
            return;
        }
        if (debounce) {
            clearTimeout(timeout);
            timeout = setTimeout(next, ms);
            return;
        }
    }
    return Object.assign(throttled, { flush, clear });
}
exports.throttle = throttle;
/**
 * Given a `fn`, return a wrapper that accepts an array of `fn` arguments.
 */
function spread(fn) {
    return (args) => fn(...args);
}
exports.spread = spread;
/**
 * Flip a binary `fn` argument order.
 */
function flip(fn) {
    return (arg2, arg1) => fn(arg1, arg2);
}
exports.flip = flip;
function partial(fn, ...args1) {
    return (...args2) => fn(...args1, ...args2);
}
exports.partial = partial;
const SEQUENCE_FNS = Object.create(null);
function sequence(...fns) {
    const n = fns.length;
    let fn = SEQUENCE_FNS[n];
    if (!fn) {
        const params = fns.map((_, i) => `_${i}`);
        const seq = params.reduce((x, p) => `${p}(${x})`, "x");
        fn = SEQUENCE_FNS[n] = new Function(...params, `return function sequence${n}(x) { return ${seq}; }`);
    }
    return fn(...fns);
}
exports.sequence = sequence;
const COMPOSE_FNS = Object.create(null);
function compose(...fns) {
    const n = fns.length;
    let fn = COMPOSE_FNS[n];
    if (!fn) {
        const params = fns.map((_, i) => `_${i}`);
        const seq = params.reduceRight((x, p) => `${p}(${x})`, "x");
        fn = COMPOSE_FNS[n] = new Function(...params, `return function compose${n}(x) { return ${seq}; }`);
    }
    return fn(...fns);
}
exports.compose = compose;
const NARY_FNS = Object.create(null);
function nary(n, origFn) {
    let fn = NARY_FNS[n];
    if (!fn) {
        const args = Array.from({ length: n }, (_, i) => `_${i}`).join(", ");
        fn = NARY_FNS[n] = new Function("origFn", `return function nary${n}(${args}) { return origFn(${args}); }`);
    }
    return fn(origFn);
}
exports.nary = nary;
//# sourceMappingURL=index.js.map