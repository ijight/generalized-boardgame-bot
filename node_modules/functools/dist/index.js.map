{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["export const add = (a: number, b: number) => a + b;\nexport const subtract = (a: number, b: number) => a - b;\nexport const multiply = (a: number, b: number) => a * b;\nexport const divide = (a: number, b: number) => a / b;\n\n/**\n * Always returns the same value supplied to it.\n */\nexport const identity = <T>(value: T) => value;\n\n/**\n * Returns a function that always returns the same value supplied to it.\n */\nexport const always = <T>(value: T) => () => value;\n\n/**\n * Minimum required cache interface.\n */\nexport interface Cache<T, U> {\n  get(key: T): U | undefined;\n  set(key: T, value: U): void;\n  has(key: T): boolean;\n}\n\n/**\n * Optimize a function to speed up consecutive calls by caching the result of\n * calls with identical input arguments. The cache can be overridden to\n * implement features such as LRU eviction.\n */\nexport function memoize<T, U>(\n  fn: (arg: T) => U,\n  cache: Cache<T, U> = new Map()\n) {\n  return function(arg: T): U {\n    if (cache.has(arg)) return cache.get(arg)!;\n\n    const result = fn(arg);\n    cache.set(arg, result);\n    return result;\n  };\n}\n\n/**\n * Memoize the result of `fn` after the first invocation.\n */\nexport function memoize0<T>(fn: () => T) {\n  let cached = false;\n  let result: T | undefined = undefined;\n\n  return (): T => {\n    if (!cached) {\n      result = fn();\n      cached = true;\n    }\n\n    return result!;\n  };\n}\n\n/**\n * Compare two arrays for equality.\n */\nexport function arrayEqual<T extends any[]>(prev: T, next: T) {\n  const len = next.length;\n  if (prev.length !== len) return false;\n\n  for (let i = 0; i < len; i++) {\n    if (!Object.is(prev[i], next[i])) return false;\n  }\n\n  return true;\n}\n\n/**\n * Memoize the result of a function based on the most recent arguments.\n */\nexport function memoizeOne<T extends any[], R>(fn: (...args: T) => R) {\n  let prevArgs: T | undefined;\n  let result: R | undefined;\n\n  return (...args: T): R => {\n    if (prevArgs === undefined || !arrayEqual(args, prevArgs)) {\n      prevArgs = args;\n      result = fn(...args);\n    }\n\n    return result!;\n  };\n}\n\n/**\n * Return a function that fetches `key` from its operand.\n */\nexport function prop<K extends string | number | symbol>(key: K) {\n  return <T extends { [T in K]?: any }>(obj: T): T[K] => obj[key];\n}\n\nexport type InvokeResult<\n  T extends (...args: A) => any,\n  A extends any[]\n> = T extends (...args: A) => infer R ? R : never;\n\n/**\n * Return a function that calls the method name on its operand. If additional\n * arguments are given, they will be given to the method as well.\n */\nexport function invoke<K extends string | number | symbol, A extends any[]>(\n  key: K,\n  ...args: A\n) {\n  return <T extends Record<K, (...args: A) => any>>(\n    obj: T\n  ): InvokeResult<T[K], A> => obj[key](...args);\n}\n\n/**\n * Throttle configuration.\n */\nexport interface ThrottleOptions {\n  leading?: boolean;\n  trailing?: boolean;\n  debounce?: boolean;\n}\n\n/**\n * Wrap a function to rate-limit the function executions to once every `ms` milliseconds.\n */\nexport function throttle<T extends any[]>(\n  fn: (...args: T) => void,\n  ms: number,\n  { leading = true, trailing = true, debounce = false }: ThrottleOptions = {}\n) {\n  let pending: T | undefined;\n  let timeout: any = undefined;\n\n  // Clear timeout.\n  function clear() {\n    clearTimeout(timeout);\n    timeout = undefined;\n    pending = undefined;\n  }\n\n  // Invoke the function in \"pending\" state.\n  function flush() {\n    clearTimeout(timeout);\n    return next();\n  }\n\n  // Execute `fn` and increment timeout every loop.\n  function next() {\n    timeout = undefined;\n    if (!pending) return;\n\n    const args = pending;\n    pending = undefined;\n    if (trailing) fn(...args);\n    timeout = setTimeout(next, ms);\n  }\n\n  // Throttled `fn` wrapper.\n  function throttled(...args: T) {\n    pending = args;\n\n    if (timeout === undefined) {\n      if (leading) {\n        pending = undefined;\n        fn(...args);\n      }\n\n      timeout = setTimeout(next, ms);\n      return;\n    }\n\n    if (debounce) {\n      clearTimeout(timeout);\n      timeout = setTimeout(next, ms);\n      return;\n    }\n  }\n\n  return Object.assign(throttled, { flush, clear });\n}\n\n/**\n * Given a `fn`, return a wrapper that accepts an array of `fn` arguments.\n */\nexport function spread<T extends any[], R>(fn: (...args: T) => R) {\n  return (args: T) => fn(...args);\n}\n\n/**\n * Flip a binary `fn` argument order.\n */\nexport function flip<T1, T2, R>(fn: (arg1: T1, arg2: T2) => R) {\n  return (arg2: T2, arg1: T1) => fn(arg1, arg2);\n}\n\n/**\n * Returns a partially applied `fn` with the supplied arguments.\n */\nexport function partial<U extends any[], R>(\n  fn: (...args: U) => R\n): (...args: U) => R;\nexport function partial<T1, U extends any[], R>(\n  fn: (arg1: T1, ...args: U) => R,\n  arg1: T1\n): (...args: U) => R;\nexport function partial<T1, T2, U extends any[], R>(\n  fn: (arg1: T1, arg2: T2, ...args: U) => R,\n  arg1: T1,\n  arg2: T2\n): (...args: U) => R;\nexport function partial<T1, T2, T3, U extends any[], R>(\n  fn: (arg1: T1, arg2: T2, arg3: T3, ...args: U) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3\n): (...args: U) => R;\nexport function partial<T1, T2, T3, T4, U extends any[], R>(\n  fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, ...args: U) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4\n): (...args: U) => R;\nexport function partial<T1, T2, T3, T4, T5, U extends any[], R>(\n  fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, ...args: U) => R,\n  arg1: T1,\n  arg2: T2,\n  arg3: T3,\n  arg4: T4,\n  arg5: T5\n): (...args: U) => R;\nexport function partial<R>(fn: (...args: any[]) => R, ...args1: any[]) {\n  return (...args2: any[]) => fn(...args1, ...args2);\n}\n\nconst SEQUENCE_FNS: Record<number, Function | undefined> = Object.create(null);\n\n/**\n * Left-to-right function composition.\n */\nexport function sequence<T1, T2>(fn1: (arg: T1) => T2): (arg: T1) => T2;\nexport function sequence<T1, T2, T3>(\n  fn1: (arg: T1) => T2,\n  fn2: (arg: T2) => T3\n): (arg: T1) => T3;\nexport function sequence<T1, T2, T3, T4>(\n  fn1: (arg: T1) => T2,\n  fn2: (arg: T2) => T3,\n  fn3: (arg: T3) => T4\n): (arg: T1) => T4;\nexport function sequence<T1, T2, T3, T4, T5>(\n  fn1: (arg: T1) => T2,\n  fn2: (arg: T2) => T3,\n  fn3: (arg: T3) => T4,\n  fn4: (arg: T4) => T5\n): (arg: T1) => T5;\nexport function sequence<T1, T2, T3, T4, T5, T6>(\n  fn1: (arg: T1) => T2,\n  fn2: (arg: T2) => T3,\n  fn3: (arg: T3) => T4,\n  fn4: (arg: T4) => T5,\n  fn5: (arg: T5) => T6\n): (arg: T1) => T6;\nexport function sequence<T>(...fns: Array<(arg: T) => T>) {\n  const n = fns.length;\n  let fn = SEQUENCE_FNS[n];\n\n  if (!fn) {\n    const params = fns.map((_, i) => `_${i}`);\n    const seq = params.reduce((x, p) => `${p}(${x})`, \"x\");\n\n    fn = SEQUENCE_FNS[n] = new Function(\n      ...params,\n      `return function sequence${n}(x) { return ${seq}; }`\n    );\n  }\n\n  return fn(...fns);\n}\n\nconst COMPOSE_FNS: Record<number, Function | undefined> = Object.create(null);\n\n/**\n * Right-to-left function composition.\n */\nexport function compose<T1, T2>(fn1: (arg: T1) => T2): (arg: T1) => T2;\nexport function compose<T1, T2, T3>(\n  fn2: (arg: T2) => T3,\n  fn1: (arg: T1) => T2\n): (arg: T1) => T3;\nexport function compose<T1, T2, T3, T4>(\n  fn3: (arg: T3) => T4,\n  fn2: (arg: T2) => T3,\n  fn1: (arg: T1) => T2\n): (arg: T1) => T4;\nexport function compose<T1, T2, T3, T4, T5>(\n  fn4: (arg: T4) => T5,\n  fn3: (arg: T3) => T4,\n  fn2: (arg: T2) => T3,\n  fn1: (arg: T1) => T2\n): (arg: T1) => T5;\nexport function compose<T1, T2, T3, T4, T5, T6>(\n  fn5: (arg: T5) => T6,\n  fn4: (arg: T4) => T5,\n  fn3: (arg: T3) => T4,\n  fn2: (arg: T2) => T3,\n  fn1: (arg: T1) => T2\n): (arg: T1) => T6;\nexport function compose<T>(...fns: Array<(arg: T) => T>) {\n  const n = fns.length;\n  let fn = COMPOSE_FNS[n];\n\n  if (!fn) {\n    const params = fns.map((_, i) => `_${i}`);\n    const seq = params.reduceRight((x, p) => `${p}(${x})`, \"x\");\n\n    fn = COMPOSE_FNS[n] = new Function(\n      ...params,\n      `return function compose${n}(x) { return ${seq}; }`\n    );\n  }\n\n  return fn(...fns);\n}\n\nconst NARY_FNS: Record<number, Function | undefined> = Object.create(null);\n\n/**\n * Fix the number of receivable arguments in `origFn` to `n`.\n */\nexport function nary<U extends any[], R>(n: 0, origFn: () => R): () => R;\nexport function nary<T1, U extends any[], R>(\n  n: 1,\n  origFn: (arg1: T1) => R\n): (arg1: T1) => R;\nexport function nary<T1, T2, U extends any[], R>(\n  n: 2,\n  origFn: (arg1: T1, arg2: T2) => R\n): (arg1: T1, arg2: T2) => R;\nexport function nary<T1, T2, T3, U extends any[], R>(\n  n: 3,\n  origFn: (arg1: T1, arg2: T2, arg3: T3) => R\n): (arg1: T1, arg2: T2, arg3: T3) => R;\nexport function nary<T1, T2, T3, T4, U extends any[], R>(\n  n: 4,\n  origFn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R\n): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => R;\nexport function nary<T1, T2, T3, T4, T5, U extends any[], R>(\n  n: 5,\n  origFn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => R\n): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => R;\nexport function nary<T1, T2, T3, T4, T5, T6, U extends any[], R>(\n  n: 6,\n  origFn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => R\n): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => R;\nexport function nary<U extends any[], R>(n: number, origFn: (...args: U) => R) {\n  let fn = NARY_FNS[n];\n\n  if (!fn) {\n    const args = Array.from({ length: n }, (_, i) => `_${i}`).join(\", \");\n\n    fn = NARY_FNS[n] = new Function(\n      \"origFn\",\n      `return function nary${n}(${args}) { return origFn(${args}); }`\n    );\n  }\n\n  return fn(origFn);\n}\n"]}